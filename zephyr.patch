diff --git a/drivers/i2c/Kconfig.gpio b/drivers/i2c/Kconfig.gpio
index fba522cc35..ea01e1abdb 100644
--- a/drivers/i2c/Kconfig.gpio
+++ b/drivers/i2c/Kconfig.gpio
@@ -10,6 +10,18 @@ config I2C_GPIO
 	help
 	  Enable software driven (bit banging) I2C support using GPIO pins
 
+config I2C_GPIO_SDA_NO_OPENDRAIN
+       bool "GPIO Bit Bang I2C pin for SDA is open drain"
+       depends on I2C_GPIO
+       help
+	  If enable, SDA is not configured as open drain.
+
+config I2C_GPIO_SCL_NO_OPENDRAIN
+       bool "GPIO Bit Bang I2C pin for SCL is open drain"
+       depends on I2C_GPIO
+       help
+	  If enable, SCL is not configured as open drain.
+
 # ---------- Port 0 ----------
 
 config I2C_GPIO_0
diff --git a/drivers/i2c/i2c_bitbang.c b/drivers/i2c/i2c_bitbang.c
index 002b6f1c23..e2effaddac 100644
--- a/drivers/i2c/i2c_bitbang.c
+++ b/drivers/i2c/i2c_bitbang.c
@@ -56,6 +56,10 @@ int i2c_bitbang_configure(struct i2c_bitbang *context, u32_t dev_config)
 		context->delays[T_LOW]  = NS_TO_SYS_CLOCK_HW_CYCLES(1300);
 		context->delays[T_HIGH] = NS_TO_SYS_CLOCK_HW_CYCLES(600);
 		break;
+	case I2C_SPEED_FAST_PLUS:
+		context->delays[T_LOW]  = NS_TO_SYS_CLOCK_HW_CYCLES(500);
+		context->delays[T_HIGH] = NS_TO_SYS_CLOCK_HW_CYCLES(260);
+		break;
 	default:
 		return -ENOTSUP;
 	}
@@ -63,9 +67,16 @@ int i2c_bitbang_configure(struct i2c_bitbang *context, u32_t dev_config)
 	return 0;
 }
 
+static int i2c_get_scl(struct i2c_bitbang *context)
+{
+	return context->io->get_scl(context->io_context);
+}
+
 static void i2c_set_scl(struct i2c_bitbang *context, int state)
 {
 	context->io->set_scl(context->io_context, state);
+	if (state)
+		while (!i2c_get_scl(context->io_context));
 }
 
 static void i2c_set_sda(struct i2c_bitbang *context, int state)
@@ -89,38 +100,26 @@ static void i2c_delay(unsigned int cycles_to_wait)
 
 static void i2c_start(struct i2c_bitbang *context)
 {
-	if (!i2c_get_sda(context)) {
-		/*
-		 * SDA is already low, so we need to do something to make it
-		 * high. Try pulsing clock low to get slave to release SDA.
-		 */
-		i2c_set_scl(context, 0);
-		i2c_delay(context->delays[T_LOW]);
-		i2c_set_scl(context, 1);
-		i2c_delay(context->delays[T_SU_STA]);
-	}
 	i2c_set_sda(context, 0);
 	i2c_delay(context->delays[T_HD_STA]);
+	i2c_set_scl(context, 0);
+	i2c_delay(context->delays[T_LOW]);
 }
 
 static void i2c_repeated_start(struct i2c_bitbang *context)
 {
+	i2c_set_sda(context, 1);
+	i2c_delay(context->delays[T_HIGH]);
+	i2c_set_scl(context, 1);
 	i2c_delay(context->delays[T_SU_STA]);
 	i2c_start(context);
 }
 
 static void i2c_stop(struct i2c_bitbang *context)
 {
-	if (i2c_get_sda(context)) {
-		/*
-		 * SDA is already high, so we need to make it low so that
-		 * we can create a rising edge. This means we're effectively
-		 * doing a START.
-		 */
-		i2c_delay(context->delays[T_SU_STA]);
-		i2c_set_sda(context, 0);
-		i2c_delay(context->delays[T_HD_STA]);
-	}
+	i2c_set_sda(context, 0);
+	i2c_delay(context->delays[T_LOW]);
+	i2c_set_scl(context, 1);
 	i2c_delay(context->delays[T_SU_STP]);
 	i2c_set_sda(context, 1);
 	i2c_delay(context->delays[T_BUF]); /* In case we start again too soon */
@@ -128,47 +127,57 @@ static void i2c_stop(struct i2c_bitbang *context)
 
 static void i2c_write_bit(struct i2c_bitbang *context, int bit)
 {
-	i2c_set_scl(context, 0);
-	/* SDA hold time is zero, so no need for a delay here */
 	i2c_set_sda(context, bit);
 	i2c_delay(context->delays[T_LOW]);
 	i2c_set_scl(context, 1);
 	i2c_delay(context->delays[T_HIGH]);
+	i2c_set_scl(context, 0);
+	i2c_delay(context->delays[T_LOW]);
 }
 
 static bool i2c_read_bit(struct i2c_bitbang *context)
 {
 	bool bit;
 
-	i2c_set_scl(context, 0);
-	/* SDA hold time is zero, so no need for a delay here */
-	i2c_set_sda(context, 1); /* Stop driving low, so slave has control */
-	i2c_delay(context->delays[T_LOW]);
-	bit = i2c_get_sda(context);
 	i2c_set_scl(context, 1);
 	i2c_delay(context->delays[T_HIGH]);
+	bit = i2c_get_sda(context);
+	i2c_set_scl(context, 0);
+	i2c_delay(context->delays[T_LOW]);
 	return bit;
 }
 
 static bool i2c_write_byte(struct i2c_bitbang *context, u8_t byte)
 {
 	u8_t mask = 1 << 7;
+	bool bit;
 
 	do {
 		i2c_write_bit(context, byte & mask);
 	} while (mask >>= 1);
+	i2c_set_sda(context, 1);
+	i2c_delay(context->delays[T_HIGH]);
+	i2c_set_scl(context, 1);
+	i2c_delay(context->delays[T_HIGH]);
 
 	/* Return inverted ACK bit, i.e. 'true' for ACK, 'false' for NACK */
-	return !i2c_read_bit(context);
+	bit = i2c_read_bit(context);
+	i2c_set_scl(context, 0);
+	i2c_delay(context->delays[T_LOW]);
+	return !bit;
 }
 
 static u8_t i2c_read_byte(struct i2c_bitbang *context)
 {
 	unsigned int byte = 1U;
 
+	i2c_set_sda(context, 1);
+	i2c_delay(context->delays[T_HIGH]);
 	do {
 		byte <<= 1;
 		byte |= i2c_read_bit(context);
+		if (!(byte & (1 << 8)))
+			i2c_delay(context->delays[T_LOW]);
 	} while (!(byte & (1 << 8)));
 
 	return byte;
@@ -179,6 +188,7 @@ int i2c_bitbang_transfer(struct i2c_bitbang *context,
 			   u16_t slave_address)
 {
 	u8_t *buf, *buf_end;
+	struct i2c_msg *msg = msgs;
 	unsigned int flags;
 	int result = -EIO;
 
@@ -186,42 +196,21 @@ int i2c_bitbang_transfer(struct i2c_bitbang *context,
 		return 0;
 	}
 
-	/* We want an initial Start condition */
-	flags = I2C_MSG_RESTART;
-
-	/* Make sure we're in a good state so slave recognises the Start */
-	i2c_set_scl(context, 1);
-	flags |= I2C_MSG_STOP;
-
+	i2c_start(context);
 	do {
-		/* Stop flag from previous message? */
-		if (flags & I2C_MSG_STOP) {
-			i2c_stop(context);
-		}
-
-		/* Forget old flags except start flag */
-		flags &= I2C_MSG_RESTART;
-
 		/* Start condition? */
-		if (flags & I2C_MSG_RESTART) {
-			i2c_start(context);
-		} else if (msgs->flags & I2C_MSG_RESTART) {
+		if (msgs != msg)
 			i2c_repeated_start(context);
-		}
 
 		/* Get flags for new message */
-		flags |= msgs->flags;
+		flags = msgs->flags;
 
 		/* Send address after any Start condition */
-		if (flags & I2C_MSG_RESTART) {
-			unsigned int byte0 = slave_address << 1;
+		unsigned int byte0 = slave_address << 1;
 
-			byte0 |= (flags & I2C_MSG_RW_MASK) == I2C_MSG_READ;
-			if (!i2c_write_byte(context, byte0)) {
-				goto finish; /* No ACK received */
-			}
-			flags &= ~I2C_MSG_RESTART;
-		}
+		byte0 |= (flags & I2C_MSG_RW_MASK) == I2C_MSG_READ;
+		if (!i2c_write_byte(context, byte0))
+			goto finish; /* No ACK received */
 
 		/* Transfer data */
 		buf = msgs->buf;
@@ -230,6 +219,16 @@ int i2c_bitbang_transfer(struct i2c_bitbang *context,
 			/* Read */
 			while (buf < buf_end) {
 				*buf++ = i2c_read_byte(context);
+				if (buf - msgs->buf == 1 &&
+				    (flags & I2C_MSG_RECV_LEN)) {
+					if (*msgs->buf <= 0){
+						i2c_write_bit(context, 1);
+						result = -EPROTO;
+						goto finish;
+					}
+					msgs->len = *msgs->buf;
+					buf_end = buf + msgs->len;
+				}
 				/* ACK the byte, except for the last one */
 				i2c_write_bit(context, buf == buf_end);
 			}
diff --git a/drivers/i2c/i2c_bitbang.h b/drivers/i2c/i2c_bitbang.h
index 796b497864..9d6eef9824 100644
--- a/drivers/i2c/i2c_bitbang.h
+++ b/drivers/i2c/i2c_bitbang.h
@@ -14,6 +14,8 @@ struct i2c_bitbang_io {
 	void (*set_scl)(void *io_context, int state);
 	/* Set the state of the SDA line (zero/non-zero value) */
 	void (*set_sda)(void *io_context, int state);
+	/* Return the state of the SCL line (zero/non-zero value) */
+	int (*get_scl)(void *io_context);
 	/* Return the state of the SDA line (zero/non-zero value) */
 	int (*get_sda)(void *io_context);
 };
diff --git a/drivers/i2c/i2c_gpio.c b/drivers/i2c/i2c_gpio.c
index 5ff62eedee..dc75d4cf79 100644
--- a/drivers/i2c/i2c_gpio.c
+++ b/drivers/i2c/i2c_gpio.c
@@ -45,14 +45,45 @@ static void i2c_gpio_set_scl(void *io_context, int state)
 {
 	struct i2c_gpio_context *context = io_context;
 
+#ifdef CONFIG_I2C_GPIO_SCL_NO_OPENDRAIN
+	if (state)
+		gpio_pin_configure(context->gpio, context->scl_pin,
+				   GPIO_DIR_IN);
+	else {
+		gpio_pin_write(context->gpio, context->scl_pin, 0);
+		gpio_pin_configure(context->gpio, context->scl_pin,
+				   GPIO_DIR_OUT);
+	}
+#else
 	gpio_pin_write(context->gpio, context->scl_pin, state);
+#endif
 }
 
 static void i2c_gpio_set_sda(void *io_context, int state)
 {
 	struct i2c_gpio_context *context = io_context;
 
+#ifdef CONFIG_I2C_GPIO_SDA_NO_OPENDRAIN
+	if (state)
+		gpio_pin_configure(context->gpio, context->sda_pin,
+				   GPIO_DIR_IN);
+	else {
+		gpio_pin_write(context->gpio, context->sda_pin, 0);
+		gpio_pin_configure(context->gpio, context->sda_pin,
+				   GPIO_DIR_OUT);
+	}
+#else
 	gpio_pin_write(context->gpio, context->sda_pin, state);
+#endif
+}
+
+static int i2c_gpio_get_scl(void *io_context)
+{
+	struct i2c_gpio_context *context = io_context;
+	u32_t state;
+
+	gpio_pin_read(context->gpio, context->scl_pin, &state);
+	return state;
 }
 
 static int i2c_gpio_get_sda(void *io_context)
@@ -67,6 +98,7 @@ static int i2c_gpio_get_sda(void *io_context)
 static const struct i2c_bitbang_io io_fns = {
 	.set_scl = &i2c_gpio_set_scl,
 	.set_sda = &i2c_gpio_set_sda,
+	.get_scl = &i2c_gpio_get_scl,
 	.get_sda = &i2c_gpio_get_sda,
 };
 
@@ -103,6 +135,19 @@ static int i2c_gpio_init(struct device *dev)
 	context->sda_pin = config->sda_pin;
 	context->scl_pin = config->scl_pin;
 
+#ifdef CONFIG_I2C_GPIO_SDA_NO_OPENDRAIN
+	gpio_pin_configure(context->gpio, context->sda_pin, GPIO_DIR_IN);
+#else
+	gpio_pin_write(context->gpio, context->sda_pin, 1);
+	gpio_pin_configure(context->gpio, context->sda_pin, GPIO_DIR_OUT);
+#endif
+#ifdef CONFIG_I2C_GPIO_SCL_NO_OPENDRAIN
+	gpio_pin_configure(context->gpio, context->scl_pin, GPIO_DIR_IN);
+#else
+	gpio_pin_write(context->gpio, context->scl_pin, 1);
+	gpio_pin_configure(context->gpio, context->scl_pin, GPIO_DIR_OUT);
+#endif
+
 	i2c_bitbang_init(&context->bitbang, &io_fns, context);
 
 	return 0;
diff --git a/include/drivers/i2c.h b/include/drivers/i2c.h
index 6121569677..2ae6749e5c 100644
--- a/include/drivers/i2c.h
+++ b/include/drivers/i2c.h
@@ -96,6 +96,11 @@ extern "C" {
  * @note Not all SoC I2C implementations support this feature. */
 #define I2C_MSG_ADDR_10_BITS		BIT(3)
 
+/** Length will be first received byte.
+ *
+ * @note Not all SoC I2C implementations support this feature. */
+#define I2C_MSG_RECV_LEN		BIT(4)
+
 /**
  * @brief One I2C Message.
  *
@@ -121,6 +126,9 @@ struct i2c_msg {
 	u8_t		flags;
 };
 
+/** As specified in SMBus standard */
+#define I2C_SMBUS_BLOCK_MAX		32
+
 /**
  * @cond INTERNAL_HIDDEN
  *
diff --git a/west.yml b/west.yml
index e0a83ee0aa..f30d751158 100644
--- a/west.yml
+++ b/west.yml
@@ -19,6 +19,8 @@ manifest:
     remote: upstream
 
   remotes:
+    - name: sv-scm
+      url-base: git://sv-scm.atmark.tech/git/hanada/zephyr-v2
     - name: upstream
       url-base: https://github.com/zephyrproject-rtos
     - name: civetweb
@@ -110,6 +112,10 @@ manifest:
     - name: littlefs
       path: modules/fs/littlefs
       revision: fe9572dd5a9fcf93a249daa4233012692bd2881d
+    - name: se_hostlib
+      remote: sv-scm
+      path: modules/lib/se_hostlib
+      revision: 6112379d40a5455a63f1db2e07435795c6a003ce
 
   self:
     path: zephyr
